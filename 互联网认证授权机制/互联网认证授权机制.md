# 互联网认证授权机制

## 1.认证授权机制

认证授权机制无非是解决两个问题：

- 认证：确定申请授权者的身份，通常有几种方式：
    1. 比对用户名和密码。
    2. 通过id确认身份
    3. 读取令牌中的身份信息。
- 授权：授权时确认申请者的权限，通过令牌等方式授予访问资源的权限

## 2.最简单的认证授权场景与机制

我们来考虑最简单的一种认证授权场景，用户每次使用用户名和密码向服务器请求资源

```mermaid
sequenceDiagram
    participant 用户
    participant 服务

    用户->>服务: 请求资源（携带用户名和密码）
    服务->>服务: 验证用户名和密码
    服务-->>用户: 认证成功，返回资源
```

这种机制有两个缺点：

1. 每次请求都需要用户输入用户名和密码，且每个请求都携带用户名和密码，有安全风险
2. 用户名和密码泄露时无法防御

## 3.使用`session_id`的认证授权

为了解决每次访问都要传递用户名和密码的问题，我们可以使用`session_id`方案。该方案中客户端只需要像服务传递一次用户名和密码，服务端会返回一个`session_id`，客户端下次请求时只需要携带`session_id`即可。

```mermaid
sequenceDiagram
participant 用户
participant 客户端
participant 服务端

用户->>客户端: 输入用户名和密码
客户端->>服务端: 发送用户名和密码
服务端->>服务端: 验证用户名和密码
服务端-->>客户端: 返回session_id
客户端->>服务端: 请求资源（携带session_id）
服务端->>服务端: 验证session_id
服务端-->>客户端: 认证成功，返回资源
```

这种方案的优点是：

1. 客户端只需要传递一次用户名和密码
2. `session_id`泄露后可以直接修改id-用户映射表

这种方案的缺点是：

1. 服务端需要维护`session_id`到用户的映射

## 4. 使用`JWT`的认证授权

### 4.1 `JWT`简介

`JWT`是`JSON Web Token`的缩写，是最常用的一种令牌。  
由三部分组成`header.payload.signature`，其中`header`是说明令牌类型和加密算法的元数据，`payload`是携带的用户数据，`signature`是加密签名。
有两类可以使用的加密签名算法：

1. 消息验证码算法，如`HMAC`：，只有拥有密钥一方（授权服务）才可以生成正确的签名，也只有拥有密钥（授权服务）一方才可以验证签名。
2. 非对称加密算法，如`RSA`：，只有拥有私钥的一方（授权服务）才可以生成正确的签名，只有拥有公钥的一方（授权服务和资源服务）才可以验证签名。

### 4.2 使用`JWT`的认证授权机制

服务端可以利用密钥生成`JWT`，只要在请求服务时携带`JWT`即可。而不需要维持`session_id`到用户的映射表。

```mermaid
sequenceDiagram
participant 用户
participant 客户端
participant 服务端

用户->>客户端: 输入用户名和密码
客户端->>服务端: 发送用户名和密码
服务端->>服务端: 验证用户名和密码
服务端-->>客户端: 返回JWT
客户端->>服务端: 请求资源（携带JWT）
服务端->>服务端: 验证JWT
服务端-->>客户端: 认证成功，返回资源
```

这种方案的优点是：

1. 服务端不需要维护`session_id`到用户的映射
2. `JWT`可以防止篡改，可以设置有效期，可以设置白名单，可以设置黑名单

## 5.oAuth2认证授权

### 5.1 传统认证授权机制的缺陷

上述授权机制存在一些问题：

#### 5.1.1 第三方客户端

当客户端并非服务提供方官方提供时，即为第三方客户端。
当用户使用第三方客户端访问服务时，可能并不希望将服务的用户名和密码告诉第三方客户端。

```mermaid
sequenceDiagram
participant 用户
participant 第三方客户端
participant 服务端
note over 用户,第三方客户端: 存在泄露、滥用风险
用户->>第三方客户端: 输入用户名和密码
第三方客户端->>服务端: 发送用户名和密码
```

#### 5.1.2 分散服务授权

如果用户希望获取多个服务的授权，则需要在分别在多个服务中注册、认证、授权，用户要分别维护多个身份令牌或id。

```mermaid
sequenceDiagram
participant 用户
participant 客户端
participant 服务端1
participant 服务端2
用户->>客户端: 输入用户名和密码
客户端->>服务端1: 发送用户名和密码
服务端1->>服务端1: 验证用户名和密码
服务端1-->>客户端: 返回JWT1
客户端->>服务端2: 发送用户名和密码
服务端2->>服务端2: 验证用户名和密码
服务端2-->>客户端: 返回JWT2
客户端->>服务端1: 请求资源（携带JWT1）
服务端1->>服务端1: 验证JWT1
服务端1-->>客户端: 认证成功，返回资源
客户端->>服务端2: 请求资源（携带JWT2）
服务端2->>服务端2: 验证JWT2
服务端2-->>客户端: 认证成功，返回资源
```

#### 5.2 oAuth2认证授权机制

使用oAuth2可以解决第三方客户端获取资源服务和分散服务授权的问题。此时通过一个用户与资源服务都信赖的授权服务实现所有认证授权。oAuth2利用重定向和令牌机制，无令牌访问资源服务时会重定向至授权服务页面，用户登录后授权服务会将授权码（后续用以换取令牌）或令牌以重定向方式传回客户端，客户端使用令牌来完成后续的资源服务访问。

#### 5.3 oAuth2的几种流程

| 流程                | 适用场景                | 是否需要用户参与 | 是否需要 `client_secret` | 安全性 |
|---------------------|------------------------|----------------|------------------------|--------|
| 授权码模式          | Web 后端应用           | 是             | 是                     | ⭐⭐⭐⭐ |
| 简化模式（不推荐）  | SPA                   | 是             | 否                     | ⭐     |
| 密码模式            | 受信任的内部应用       | 是             | 是                     | ⭐⭐   |
| 客户端凭证模式      | 服务间调用             | 否             | 是                     | ⭐⭐⭐ |
| PKCE 扩展           | 移动端/SPA             | 是             | 否                     | ⭐⭐⭐⭐ |

#### 5.4 授权码模式

授权码模式是最安全的一种oAuth2流程，它使用授权码来交换令牌。这种模式需要有客户端后端。

```mermaid
sequenceDiagram
    participant User as 用户
    participant Browser as 用户代理（浏览器）
    participant ClientBackend as 客户端后端
    participant AuthServer as 授权服务器
    participant ResourceServer as 资源服务器

    User->>Browser: 1. 访问客户端前端页面
    Browser->>ClientBackend: 2. 请求登录
    ClientBackend->>Browser: 3. 重定向到授权服务器（带client_id/redirect_uri）
    Browser->>AuthServer: 4. 用户登录并授权
    AuthServer->>Browser: 5. 重定向回客户端（URL中含授权码code）
    Browser->>ClientBackend: 6. 将授权码发送到客户端后端（非前端！）
    ClientBackend->>AuthServer: 7. 用code+client_secret交换令牌
    AuthServer->>ClientBackend: 8. 返回access_token和refresh_token
    ClientBackend->>ResourceServer: 9. 用access_token请求资源
    ResourceServer->>ClientBackend: 10. 返回受保护资源

```

>在授权模式中，会假设客户端能比浏览器更安全的保存与使用令牌，因此浏览器仅仅知道一次性授权码，而不持有令牌。

##### 5.5 客户端凭证模式

客户端凭证模式适用于机器对机器场景（如后台服务间通信），同时假设客户端可以安全的持有令牌。

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant AuthServer as 授权服务器
    participant ResourceServer as 资源服务器

    Note over Client: 客户端持有自己的凭证(client_id + client_secret)
    Client->>AuthServer: 1. 请求访问令牌<br>(POST /token)<br>grant_type=client_credentials<br>client_id + client_secret
    AuthServer-->>Client: 2. 返回访问令牌<br>(access_token)
    Client->>ResourceServer: 3. 携带令牌访问资源<br>(Authorization: Bearer access_token)
    ResourceServer-->>Client: 4. 返回受保护资源

```

##### 5.6 PKCE扩展模式

如果客户端没有后端，可以采用简化模式（类似于客户端凭证模式，但并不足够安全），或采用PKCE拓展模式（推荐）。以下是PKCE拓展模式的时序图：

```mermaid
sequenceDiagram
    participant User as 用户
    participant SPA as 单页应用(SPA)
    participant AuthService as 授权服务
    participant ResourceService as 资源服务

    Note over SPA: PKCE准备阶段
    SPA->>SPA: 生成code_verifier
    SPA->>SPA: 计算code_challenge(S256)
    
    User->>SPA: 点击登录
    SPA->>AuthService: 授权请求(带code_challenge)
    Note right of AuthService: GET /authorize?<br>response_type=code<br>&client_id=...<br>&redirect_uri=...<br>&code_challenge=...<br>&code_challenge_method=S256
    
    AuthService->>User: 显示认证页面
    User->>AuthService: 输入凭据并授权
    AuthService->>SPA: 返回授权码(带code)
    Note left of SPA: 回调URL?code=...<br>(PKCE绑定授权码)
    
    SPA->>AuthService: 用code_verifier换取token
    Note right of AuthService: POST /token<br>grant_type=authorization_code<br>&code=...<br>&redirect_uri=...<br>&client_id=...<br>&code_verifier=...
    
    AuthService->>SPA: 返回访问令牌
    Note left of SPA: {access_token, refresh_token, expires_in}
    
    SPA->>ResourceService: 携带访问令牌请求资源
    Note right of ResourceService: GET /api<br>Authorization: Bearer {access_token}
    
    ResourceService->>SPA: 返回受保护资源
```
